<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.nuoyang.tech","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Atticus Blog">
<meta property="og:url" content="https://blog.nuoyang.tech/page/6/index.html">
<meta property="og:site_name" content="Atticus Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Atticus Lv">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.nuoyang.tech/page/6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Atticus Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Atticus Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Atticus Lv"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Atticus Lv</p>
  <div class="site-description" itemprop="description"></div>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.nuoyang.tech/2016/05/19/backup-Interview-Data-Structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Atticus Lv">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Atticus Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Atticus Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/05/19/backup-Interview-Data-Structure/" class="post-title-link" itemprop="url">数据结构相关问题总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-05-19 09:50:35" itemprop="dateCreated datePublished" datetime="2016-05-19T09:50:35+08:00">2016-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 17:12:49" itemprop="dateModified" datetime="2022-06-19T17:12:49+08:00">2022-06-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E8%B5%84%E6%96%99/" itemprop="url" rel="index"><span itemprop="name">技术资料</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们来总结一下数据结构相关的一些知识，这里包括最普遍的链表、二叉树问题。</p>
<h1 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是每个节点最多有两个分支的树结构，通常分支被称作<strong>左子树</strong>和<strong>右子树</strong>。二叉树的分支具有左右次序，不能颠倒。<br>二叉树的第i层最多有$2^{i-1}$个节点；深度为k的二叉树最多共有$2{k+1}-1$个节点</p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>每一层的节点数都是最大节点数，即深度为k有$2^k-1$个节点的二叉树</p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>除最后一层外，其余层都是满的，并且最后一层或者是满的，或者是在右边缺少若干节点，即为完全二叉树。深度为k的<a href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树</a>，至少有$2^{k-1}$个节点，至多有$2^k-1$个节点。</p>
<h3 id="访问二叉树的方法"><a href="#访问二叉树的方法" class="headerlink" title="访问二叉树的方法"></a>访问二叉树的方法</h3><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种自平衡二叉查找树，它可以在$O(logn)$时间内做查找、插入和删除等操作。</p>
<p><strong>红黑树的性质</strong></p>
<p>红黑树，是通过红黑两种颜色域保证树的高度近似平衡，它的每个节点是一个五元组：color(颜色)，key(数据)，left(左孩子)，right(右孩子)和p(父节点)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">红黑树定义</span><br><span class="line">性质1. 节点是红色或黑色</span><br><span class="line">性质2. 根是黑色</span><br><span class="line">性质3. 所有叶子都是黑色（叶子都是NIL节点）</span><br><span class="line">性质4. 如果一个节点是红的，则它的两个儿子都是黑的</span><br><span class="line">性质5. 从任一节点到其叶子的所有简单路径都包含相同数目的黑色节点</span><br></pre></td></tr></table></figure>
<img src="/2016/05/19/backup-Interview-Data-Structure/red-black-tree.jpg" class="" title="red-black-tree">
<p>一个关键性质：<br>从根到叶子的最长可能路径不多于最短的可能路径的两倍长</p>
<p><strong>红黑树的基本操作</strong><br>红黑树上的查找操作与普通二叉查找树上的查找操作相同，但是红黑树上的插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量（%O(logn)%）颜色变更和不超过三次树旋转（插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为%O(logn)%次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">插入操作：</span><br><span class="line">(1) 查找插入的位置，时间复杂度为O(n)</span><br><span class="line">(2) 将新节点的color赋值为红色</span><br><span class="line">(3) 自下而上重新调整该树为红黑树</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsaj/dsaj.pdf">数据结构与算法（Java 描述）</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91">Wikipedia二叉树</a></li>
<li><a target="_blank" rel="noopener" href="http://dongxicheng.org/structure/red-black-tree/">红黑树</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.nuoyang.tech/2016/01/17/backup-Interview-Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Atticus Lv">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Atticus Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Atticus Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/01/17/backup-Interview-Algorithm/" class="post-title-link" itemprop="url">程序员要会的一些算法问题总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-01-17 10:14:08" itemprop="dateCreated datePublished" datetime="2016-01-17T10:14:08+08:00">2016-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 17:12:49" itemprop="dateModified" datetime="2022-06-19T17:12:49+08:00">2022-06-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E8%B5%84%E6%96%99/" itemprop="url" rel="index"><span itemprop="name">技术资料</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>无论是面试还是平时工作，都需要掌握基本的数据结构和排序算，这里我总结下几种排序算法</p>
<h2 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h2><p>算法代码是用java实现的</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>设数组长度为n</p>
<ul>
<li>比较前后相邻两个数据，如果前面数据大于后面，将两个数据交换</li>
<li>对数组0～n-1个数据进行一次遍历后，最大的数据沉到n-1位置</li>
<li>n&#x3D;n-1，重复前两步</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort1</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span> &#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">		<span class="type">int</span> i, j;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j]) &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">					a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">					a[j - <span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;Bubble sort 1: &quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>进行优化，设置一个boolean，如果这趟发生了交换，则为true，否则为false。如果有一趟没有发生交换，说明排序已经完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort2</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span> &#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">		<span class="type">int</span> i, j;</span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">while</span>(flag)&#123;</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; k ; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j]) &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">					a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">					a[j - <span class="number">1</span>] = temp;</span><br><span class="line">					flag = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			k--;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;Bubble sort 2: &quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>再做一步优化，如果有100个数的数组，仅前面10个无序，后面90个都已经排好序，且都大于前面10个数字。在第一趟遍历后，最后发生交换的位置必定小于10，只要记录下这位置，第二次从数组头部遍历到这个位置就OK。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序3</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort3</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span> &#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">		<span class="type">int</span> i, j;</span><br><span class="line">		<span class="type">int</span> flag;</span><br><span class="line">		flag = n;</span><br><span class="line">		<span class="keyword">while</span> (flag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> flag;</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j]) &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">					a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">					a[j - <span class="number">1</span>] = temp;</span><br><span class="line">					flag = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;Bubble sort 3: &quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序我们可以简单理解为，大的数往下沉，两层循环遍历整个数组。冒泡排序效率很低，数据规模很小的时候，可以采用，规模较大时，最后采用其他排序方法。</p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>基本思想是，每次将一个带排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。<br><strong>设数组为a[0…n-1]</strong></p>
<ul>
<li>初始时，a[0]自成一个有序区，无序区为a[1…n-1]。令i&#x3D;1</li>
<li>将a[i]并入到当前有序区a[0…i-1]中，形成a[0…i]的有序区。</li>
<li>i++并重复第二步直到i&#x3D;&#x3D;n-1。排序完成。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSort3</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> a[] = &#123; <span class="number">3</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">		<span class="type">int</span> i, j, k;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>&amp;&amp;a[j]&gt;a[j+<span class="number">1</span>];j--)&#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">				a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">				a[j+<span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;Insert sort 3: &quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>实质是分组插入排序，又称为缩小增量排序，基本思想为：</p>
<ul>
<li>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成），分别进行直接插入排序</li>
<li>依次缩减增量再进行排序，待整个序列中的元素基本有序时，再对全体元素进行一次直接插入排序<br>因为直接插入排序在元素基本有序情况下（接近最好情况），效率很高，，因此希尔排序在时间效率上比前两种方法有较大提高。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">以n=10的数组为例，&#123;49,38,65,97,26,13,27,49,55,4&#125;</span><br><span class="line">-- 第一次gap=10/2=5</span><br><span class="line">	（竖着看）</span><br><span class="line">    49 38 65 97 26</span><br><span class="line">    13 27 49 55 4</span><br><span class="line">   每次对同一组的数据进行直接插入排序，即分为5组，排序后</span><br><span class="line">   13 27 49 55 4</span><br><span class="line">	 49 38 65 97 26</span><br><span class="line">-- 第二次gap=5/2=2</span><br><span class="line">  （竖着看）</span><br><span class="line">    13 27</span><br><span class="line">    49 55</span><br><span class="line">     4 49</span><br><span class="line">    38 65</span><br><span class="line">    97 26</span><br><span class="line">    排序后，为(4 13 38 49 97)，(26,27,49,55,65)</span><br><span class="line">		现在数组为&#123;4,26,13,27,38,49,49,55,97,65&#125;</span><br><span class="line">-- 第三次gap=2/2=1</span><br><span class="line">		4 26 13 27 38 49 49 55 97 65</span><br><span class="line">		排序后</span><br><span class="line">		4 13 26 27 38 49 49 55 65 97</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">int</span> a[] = &#123; <span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">26</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">55</span>,<span class="number">4</span> &#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">		<span class="type">int</span> i,j,gap;</span><br><span class="line">		<span class="keyword">for</span>(gap=n/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=gap;i&lt;n;i++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(j=i-gap;j&gt;=<span class="number">0</span>&amp;&amp;a[j]&gt;a[j+gap];j-=gap)&#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">					a[j] = a[j+gap];</span><br><span class="line">					a[j+gap] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;Shell sort: &quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><p>和直接插入排序类似，都将数据分为有序区和无序区，不同的是，直接插入排序是将无序区的第一个元素直接插入到有序区以形成一个更大的有序区，而直接选择排序是从无序区选一个最小的元素直接放到有序区的最后。<br><br>设数组为a[0…n-1]</p>
<ul>
<li>初始时，数组全为无序区，为a[0…n-1]，令i&#x3D;0</li>
<li>在无序区a[i…n-1]中选取一个最小的元素，将其与a[i]交换，交换后a[0…i]就形成一个有序区</li>
<li>i++，并重复第二步直到i&#x3D;n-1。排序完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">int</span> a[] = &#123; <span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">26</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">55</span>,<span class="number">4</span> &#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">		<span class="type">int</span> i,j,minIndex;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			minIndex = i;</span><br><span class="line">			<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[j]&lt;a[minIndex])&#123;</span><br><span class="line">					minIndex = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">			a[i] = a[minIndex];</span><br><span class="line">			a[minIndex] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;Select sort: &quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法。<br></p>
<img src="/2016/01/17/backup-Interview-Algorithm/Merge-sort-example-300px.gif" class="" title="归并排序">
<p>首先考虑下如何将两个有序数列合并，只要从比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数，然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出，效率可以达到O(n)。<br><br>解决了合并有序数列问题，再来看归并排序，基本想法是将数组分为A、B组，如果两组都是有序的，可以很方便的将这两组数据进行排序。如何让两组都是有序的？可以将AB继续再分为两组，依次类推，当分出来的小组只有一个数据时，可以认为这个小组达到有序，然后再合并相邻两个小组即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergerSort</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">123</span>, <span class="number">534</span>, <span class="number">345</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">67</span>, <span class="number">90</span>, <span class="number">34</span>, <span class="number">12</span>, <span class="number">67</span>, <span class="number">90</span>, <span class="number">32</span> &#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">		msort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			System.out.println(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">msort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">			msort(arr, low, mid);</span><br><span class="line">			msort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">			merger(arr, low, mid, high);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将两个有序数组合并成一个有序数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merger</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">		<span class="comment">// temp数组用于暂存合并的结果</span></span><br><span class="line">		<span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 左半边的指针</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low;</span><br><span class="line">		<span class="comment">// 右半边的指针</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 合并后数组的指针</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//将记录由小到大放进temp数组</span></span><br><span class="line">		<span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">				temp[k] = arr[i++];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				temp[k] = arr[j++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将剩余放到temp中</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">			temp[k++] = arr[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">			temp[k++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将temp写入到待排数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; temp.length; l++) &#123;</span><br><span class="line">			arr[low + l] = temp[l];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序由于排序效率在同为O(nlogn)的几种排序方法中效率最高的，它采用的是一种分治的策略，通常叫分治法。<br></p>
<img src="/2016/01/17/backup-Interview-Algorithm/Sorting_quicksort_anim.gif" class="" title="快速排序">
<p>基本思想：</p>
<ul>
<li>先从数列中取出一个数作为基准数</li>
<li>分区过程，将比这个数大的数全放在它的右边，小于或等于它的数放到它的左边</li>
<li>再对左右分区重复第二步，直到各区中只有一个数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">int</span> arr[] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">123</span>,<span class="number">534</span>,<span class="number">345</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">67</span>,<span class="number">90</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">67</span>,<span class="number">90</span>,<span class="number">32</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">		qsort(arr,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Quick sort: &quot;</span>);</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			System.out.println(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr,low,high);</span><br><span class="line">			qsort(arr, low, pivot-<span class="number">1</span>);</span><br><span class="line">			qsort(arr,pivot+<span class="number">1</span>,high);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[low];</span><br><span class="line">		<span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">			<span class="keyword">while</span>(low&lt;high &amp;&amp; arr[high]&gt;=pivot) --high;</span><br><span class="line">			arr[low] = arr[high];</span><br><span class="line">			<span class="keyword">while</span>(low&lt;high &amp;&amp; arr[low]&lt;=pivot) ++low;</span><br><span class="line">			arr[high] = arr[low];</span><br><span class="line">		&#125;</span><br><span class="line">		arr[low] = pivot;</span><br><span class="line">		<span class="keyword">return</span> low;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><img src="/2016/01/17/backup-Interview-Algorithm/Sorting_heapsort_anim.gif" class="" title="堆排序">
<p>先复习下数据结构的二叉堆</p>
<h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><p>二叉堆是完全二叉树或者是近似完全二叉树。<br><br>二叉堆需要满足的特性：</p>
<ul>
<li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值</li>
<li>每个节点的左子树和右子树都是一个二叉堆（最大堆或最小堆）<br>当父节点的键值总是大于或等于任何一个子节点的键值时，为最大堆。当父节点的键值总是小于或等于任何一个子节点的键值时，为最小堆。</li>
</ul>
<h4 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h4><p>一般都用数组来表示堆，i节点的父节点下标为(i-1)&#x2F;2，它的左右子节点下标分别为2×i+1和2×i+2。如第0个节点的左右子节点分别为1和2。</p>
<h4 id="堆的操作——建立插入删除"><a href="#堆的操作——建立插入删除" class="headerlink" title="堆的操作——建立插入删除"></a>堆的操作——建立插入删除</h4><ol>
<li>建立堆： 数组具有对应的树表示形式。一般情况，树并不满足堆的条件，通过重新排列元素，可以建立一棵“堆化”的树</li>
<li>插入： 新元素被加到表层，随后树被更新以恢复堆次序。</li>
<li>删除： 删除总是发生在根A[0]处，表中最后一个元素被用来填补空缺位置，结果树被更新以恢复堆条件。</li>
</ol>
<h4 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h4><p>每次插入都是将新数据放在数组最后。可以发现，从这个新数据的父节点到根节点必然为一个有序的数列。将这个新数据插入到这个有序数据中，这就类似于<a href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">直接插入排序</a>，我们可以写出一个插入一个新数据时堆的调整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">minHeapFixup</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="type">int</span> j, temp;</span><br><span class="line">		temp = a[i];</span><br><span class="line">		j = (i - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">// 父节点</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt;= temp)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			a[i] = a[j];<span class="comment">// 把较大的子节点往下移动，替换它的子节点</span></span><br><span class="line">			i = j;</span><br><span class="line">			j = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		a[i] = temp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆的删除"><a href="#堆的删除" class="headerlink" title="堆的删除"></a>堆的删除</h4><p>按照定义，堆中每次只能删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根节点，然后再从根节点开始进行一次从上向下的调整。调整时，先在左右儿子节点中找最小的，如果父节点比这个最小的子节点还小，则不需要调整，反之将父节点和它交换，然后再考虑后面的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从i节点开始调整，n为节点总数，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">minHeapFixdown</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="type">int</span> j, temp;</span><br><span class="line">		temp = a[i];</span><br><span class="line">		j = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; a[j + <span class="number">1</span>] &lt; a[j])<span class="comment">// 在左右子节点中找最小的</span></span><br><span class="line">				j++;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &gt; temp)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			a[i] = a[j];<span class="comment">// 把较小的子节点往上移动，替换父节点</span></span><br><span class="line">			i = j;</span><br><span class="line">			j = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		a[i] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//在最小堆中删除数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">minHeapDeleteNumber</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">	a[<span class="number">0</span>] = a[n-<span class="number">1</span>];</span><br><span class="line">	a[n-<span class="number">1</span>] = temp;</span><br><span class="line">	minHeapFixdown(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆化数组"><a href="#堆化数组" class="headerlink" title="堆化数组"></a>堆化数组</h4><p>有了堆的插入和删除后，考虑下如何对一个数据进行堆化操作。<br><br>考虑一个数组，A[0] &#x3D; {9,12,17,30,50,20,60,65,4,49}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//初始表</span><br><span class="line">            9</span><br><span class="line">        /       \</span><br><span class="line">      12         17</span><br><span class="line">    /    \      /  \</span><br><span class="line">   30    50    20  60</span><br><span class="line">	/ \   /</span><br><span class="line"> 65 4  19</span><br></pre></td></tr></table></figure>
<p>很明显，对于叶子节点，65，4，19，20，60，可以认为它们是一个合法的堆。只要从A[4]&#x3D;50开始往下调整就可以，然后再取A[3]&#x3D;30,A[2]&#x3D;17,A[1]&#x3D;12,A[0]&#x3D;9分别作一次向下调整操作就可以了。</p>
<img src="/2016/01/17/backup-Interview-Algorithm/Heap-Sort-Array.PNG" class="" title="堆化数组示意图">
<p>可以写出堆化数组的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeMinHeap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		minHeapFixdown(a, i, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序就是堆插入和堆删除"><a href="#堆排序就是堆插入和堆删除" class="headerlink" title="堆排序就是堆插入和堆删除"></a>堆排序就是堆插入和堆删除</h4><p>OK，我们回归正题。从上面可以看到，堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作，这样堆中第0个数据又是堆中最小的数据，重复上述步骤，直到堆中只有一个数据时，就取出这个数据。由于堆也是用数组模拟的，所以<a href="#%E5%A0%86%E5%8C%96%E6%95%B0%E7%BB%84">堆化数组</a>后，第一次将A[0]与A[n-1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n-2]交换，再对A[0…n-3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面有序区间，故操作完成后整个数组就有序了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> a[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">123</span>, <span class="number">534</span>, <span class="number">345</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">67</span>, <span class="number">90</span>, <span class="number">34</span>, <span class="number">12</span>, <span class="number">67</span>, <span class="number">90</span>, <span class="number">32</span> &#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">		<span class="comment">//建最小堆</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n -<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">			minHeapFixup(a,i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">			a[<span class="number">0</span>] = a[i];</span><br><span class="line">			a[i] = temp;</span><br><span class="line">			minHeapFixdown(a, <span class="number">0</span>, i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>注意：我们用的是最小堆排序，这样排序后得到的是递减数组，如果要得到递增数组，可以使用最大堆。由于每次重新恢复堆的时间复杂度为O(logn)，共n-1次重新恢复堆操作，再加上前面建立堆时n&#x2F;2次向下调整，每次调整时间复杂度也是O(logn),两次操作时间相加还是O(nlogn)(最终的时间复杂度)。</p>
<h2 id="常用排序算法时间复杂度和空间复杂度"><a href="#常用排序算法时间复杂度和空间复杂度" class="headerlink" title="常用排序算法时间复杂度和空间复杂度"></a>常用排序算法时间复杂度和空间复杂度</h2><p>稳定排序是所有相等的数经过排序后，仍能保持它们在排序之前的相对次序；反之，就是非稳定的排序。</p>
<table>
<thead>
<tr>
<th>排序法</th>
<th>最差时间分析</th>
<th>平均时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>直接插入排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$O(n^2)$</td>
<td>$O(n^{1.3})$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>直接选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(n^2)$</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">Wikipedia-堆排序</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/MoreWindows">白话经典算法</a></li>
<li><a target="_blank" rel="noopener" href="https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsaj/dsaj.pdf">数据结构与算法（Java 描述）</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">蜀ICP备2021011057号-2 </a>
      <img src="/images/beian.png" alt=""><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=51019002002976" rel="noopener" target="_blank">川公网安备51019002002976号 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Atticus Lv</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
